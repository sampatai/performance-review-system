# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches:
      - dev
      - stage
      - main
  pull_request:
    branches:
      - dev
      - stage
      - main

# Apply least privilege access to workflow jobs
permissions:
  id-token: write
  contents: read

jobs:
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the latest version of the repository
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 2: Setup .NET 9 SDK from official action
      - name: Setup .NET 9 SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      # Step 3: Cache NuGet packages for faster builds
      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      # Step 4: Restore all NuGet dependencies from the solution file
      - name: Restore dependencies
        run: dotnet restore ./src/OfficePerformanceReview.sln

      # Step 5: Build the .NET solution in Release mode without restoring packages again
      - name: Build solution
        run: dotnet build ./src/OfficePerformanceReview.sln --configuration Release --no-restore

      # Step 6: Run all tests in the solution with standard verbosity
      - name: Run tests
        run: dotnet test ./src/OfficePerformanceReview.sln --configuration Release --no-build --verbosity normal

  deploy:
    name: Deploy to Amazon ECS
    needs: build-and-test
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'push' &&
      (github.ref == 'refs/heads/dev' ||
       github.ref == 'refs/heads/stage' ||
       github.ref == 'refs/heads/main')

    steps:
      # Step 1: Checkout code again in this job context
      - name: 🛠️ Checkout Repository
        uses: actions/checkout@v4

      # Step 2: Configure AWS credentials for deploying via CLI and SDK
      # Requires secrets: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Step 3: This GitHub Action uses the IAM credentials (from the GitHub Secrets) to authenticate Docker with Amazon ECR, so Docker can push images there.
      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      # Step 4: Determine environment based on branch
      - name: Set environment variables
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "ENVIRONMENT=prod" >> $GITHUB_ENV
            echo "ECS_SERVICE=${{ secrets.ECS_SERVICE_PROD }}" >> $GITHUB_ENV
            echo "ECS_CLUSTER=${{ secrets.ECS_CLUSTER_PROD }}" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/stage" ]]; then
            echo "ENVIRONMENT=stage" >> $GITHUB_ENV
            echo "ECS_SERVICE=${{ secrets.ECS_SERVICE_STAGE }}" >> $GITHUB_ENV
            echo "ECS_CLUSTER=${{ secrets.ECS_CLUSTER_STAGE }}" >> $GITHUB_ENV
          else
            echo "ENVIRONMENT=dev" >> $GITHUB_ENV
            echo "ECS_SERVICE=${{ secrets.ECS_SERVICE }}" >> $GITHUB_ENV
            echo "ECS_CLUSTER=${{ secrets.ECS_CLUSTER }}" >> $GITHUB_ENV
          fi

      # Step 5: Build Docker image from WebAPI Dockerfile, tag with Git SHA, push to ECR
      # Ensure: ECR_REPOSITORY secret contains full ECR URL including repository name
      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REPOSITORY:$IMAGE_TAG -f src/WebAPI/Dockerfile src
          echo "Testing container can start successfully..."
          docker run --rm -d --name test-container $ECR_REPOSITORY:$IMAGE_TAG
          sleep 10
          docker stop test-container || true
          echo "Container test passed, proceeding with push..."
          docker tag $ECR_REPOSITORY:$IMAGE_TAG $ECR_REPOSITORY:latest
          docker push $ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REPOSITORY:latest

      # Step 6: Create environment-specific task definition from template
      - name: Create task definition from template
        run: |
          # Copy template and replace placeholders
          cp ecs-task-definition-template.json ecs-task-definition-${{ env.ENVIRONMENT }}.json
          sed -i "s|PLACEHOLDER_IMAGE_URI|${{ secrets.ECR_REPOSITORY }}:${{ github.sha }}|g" ecs-task-definition-${{ env.ENVIRONMENT }}.json
          sed -i "s|PLACEHOLDER_ENVIRONMENT|${{ env.ENVIRONMENT }}|g" ecs-task-definition-${{ env.ENVIRONMENT }}.json
          sed -i "s|PLACEHOLDER_TASK_FAMILY|${{ env.ENVIRONMENT }}-performance-review-task|g" ecs-task-definition-${{ env.ENVIRONMENT }}.json

      # Step 7: Render ECS task definition with new image
      - name: Render ECS task definition with new image
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: ecs-task-definition-${{ env.ENVIRONMENT }}.json
          container-name: officepe-review-webapi
          image: ${{ secrets.ECR_REPOSITORY }}:${{ github.sha }}

      # Step 8: Deploy the updated ECS task definition to the target service
      # Requires ECS_SERVICE and ECS_CLUSTER secrets
      - name: Deploy to Amazon ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }} #ECS needs to know where to deploy your containers. Without a cluster, it doesn’t know what infrastructure to use(run containers)
          wait-for-service-stability: true

      # Step 9: Verify deployment health
      - name: Verify deployment
        run: |
          echo "Deployment to ${{ env.ENVIRONMENT }} environment completed successfully"
          echo "Service: ${{ env.ECS_SERVICE }}"
          echo "Cluster: ${{ env.ECS_CLUSTER }}"
          echo "Image: ${{ secrets.ECR_REPOSITORY }}:${{ github.sha }}"

      # Step 10: Upload any published artifacts (if applicable)
      - name: Upload published artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: published-app-${{ github.sha }}
          path: src/WebAPI/bin/Release/net9.0/publish/
          retention-days: 30

# Additional Recommendations:
# ----------------------------
# ✅ 1. Use actions/cache for NuGet packages to improve speed. (IMPLEMENTED)
# ✅ 2. Add environment-specific deploy jobs using GitHub environments. (IMPLEMENTED)
# 3. Validate that secrets and ECS task definition are correctly formatted JSON or paths.
# 4. Optionally add manual approvals for main branch deploy via protected environments.
# 5. Consider adding security scanning with tools like Snyk or CodeQL
# 6. Add integration tests that run against the built container
